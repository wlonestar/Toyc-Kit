//! Interpreter implementation

#include <CodeGen.h>
#include <Interpreter.h>
#include <Parser.h>

#include <llvm/IR/Verifier.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/raw_ostream.h>

#include <cstdlib>
#include <exception>
#include <sstream>

namespace toyc {

/// Open the file for writing
void Interpreter::writeByteCode(std::string filename) {
  int fd;
  std::error_code ec = llvm::sys::fs::openFileForWrite(
      filename, fd, llvm::sys::fs::CD_CreateAlways, llvm::sys::fs::OF_None);
  if (ec) {
    llvm::errs() << "error opening file: " << ec.message() << "\n";
    exit(EXIT_FAILURE);
  }
  /// Create raw_fd_ostream using the file descriptor
  llvm::raw_fd_ostream file(fd, true);
  /// print out generated byte code both into file and standard error
  visitor.dump(file);
}

void Interpreter::compile(std::string &input, const char *dest) {
  /// support incremental parser
  parser.addInput(input);
  try {
    /// parse the input incrementally
    auto decl = parser.parse();
    /// if the result is not null, print the generated AST
    /// and generate IR code to global Context
    if (decl != nullptr) {

/// set AST to std::stringstream and print out
#ifdef DEBUG
      std::stringstream ss;
      decl->dump(ss);
      std::cout << ss.str();
#endif

      /// generate IR code
      visitor.codegen(*decl);
    }
  } catch (LexerException e1) {
    std::cerr << e1.what() << "\n";
    return;
  } catch (ParserException e2) {
    std::cerr << e2.what() << "\n";
    return;
  } catch (CodeGenException e3) {
    std::cerr << e3.what() << "\n";
    return;
#ifndef DEBUG
  } catch (...) {
    /// catch error for release version
    std::cerr << "there is something wrong in compiler inner\n";
    return;
#endif
  }

#ifdef DEBUG
  visitor.dump();
#endif

  bool flag = visitor.verifyModule();

  /// Specify the filename
  if (flag) {
    writeByteCode(std::string(dest));
  }
}

} // namespace toyc
